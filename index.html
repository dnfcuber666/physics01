<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>2D 氣體分子運動模擬</title>
  <style>
    body { text-align: center; background: #f5f5f5; font-family: sans-serif; }
    canvas { background: #fff; display: block; margin: 10px auto; border: 1px solid #ccc; }
    .controls { margin: 10px; }
    input, button { margin: 5px; }
    .stats { margin: 10px; font-size: 18px; }
  </style>
</head>
<body>
  <h1>2D 氣體分子運動模擬</h1>
  <div class="controls">
    <label>初始溫度: <input type="range" id="tempInput" min="1000" max="50000" value="4000" step="100"></label>
    <span id="tempValue">4000</span>
    <label>粒子數量: <input type="range" id="numInput" min="50" max="500" value="200" step="1"></label>
    <span id="numValue">200</span>
    <button id="startBtn">開始</button>
    <button id="resetBtn">停止</button>
  </div>
  <div class="stats">
    平均速度: <span id="avgSpeed">0</span> |
    RMS速度: <span id="rmsSpeed">0</span> |
    壓力: <span id="pressure">0</span> |
    <span id="avgFrames">幀數: 0</span>
  </div>
  <canvas id="simCanvas" width="600" height="400"></canvas>

<script>
const canvas = document.getElementById("simCanvas");
const ctx = canvas.getContext("2d");

let particles = [];
let numParticles = 200;
let radius = 3;
let initialTemp = 4000;
let running = false;

const framesForAverage = 500; // 最近幀數平均
let impulseHistory = [];
let avgSpeedHistory = [];
let rmsSpeedHistory = [];

const tempInput = document.getElementById("tempInput");
const tempValue = document.getElementById("tempValue");
const numInput = document.getElementById("numInput");
const numValue = document.getElementById("numValue");

const avgSpeedEl = document.getElementById("avgSpeed");
const rmsSpeedEl = document.getElementById("rmsSpeed");
const pressureEl = document.getElementById("pressure");
const avgFramesEl = document.getElementById("avgFrames");

tempInput.addEventListener("input", () => tempValue.textContent = tempInput.value);
numInput.addEventListener("input", () => numValue.textContent = numInput.value);

function initParticles() {
  particles = [];
  let speedScale = Math.sqrt(initialTemp) / 100; // 固定初始速度大小
  for (let i = 0; i < numParticles; i++) {
    let angle = Math.random() * 2 * Math.PI;
    let vx = speedScale * Math.cos(angle);
    let vy = speedScale * Math.sin(angle);
    particles.push({
      x: Math.random() * (canvas.width - 2 * radius) + radius,
      y: Math.random() * (canvas.height - 2 * radius) + radius,
      vx: vx,
      vy: vy,
      radius: radius,
      mass: 1
    });
  }
  impulseHistory = [];
  avgSpeedHistory = [];
  rmsSpeedHistory = [];
}

// 計算滑動平均
function computeStats() {
  let totalSpeed = 0;
  let totalSpeedSq = 0;
  for (let p of particles) {
    let v = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
    totalSpeed += v;
    totalSpeedSq += v*v;
  }
  let avgSpeed = totalSpeed / particles.length;
  let rmsSpeed = Math.sqrt(totalSpeedSq / particles.length);

  avgSpeedHistory.push(avgSpeed);
  rmsSpeedHistory.push(rmsSpeed);
  if(avgSpeedHistory.length > framesForAverage) avgSpeedHistory.shift();
  if(rmsSpeedHistory.length > framesForAverage) rmsSpeedHistory.shift();

  let avgSpeedSmoothed = avgSpeedHistory.reduce((a,b)=>a+b,0)/avgSpeedHistory.length;
  let rmsSpeedSmoothed = rmsSpeedHistory.reduce((a,b)=>a+b,0)/rmsSpeedHistory.length;

  avgSpeedEl.textContent = avgSpeedSmoothed.toFixed(2);
  rmsSpeedEl.textContent = rmsSpeedSmoothed.toFixed(2);
}

// 分子碰撞處理
function handleCollisions() {
  for(let i=0;i<particles.length;i++){
    for(let j=i+1;j<particles.length;j++){
      let p1 = particles[i], p2 = particles[j];
      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < p1.radius + p2.radius){
        let nx = dx / dist;
        let ny = dy / dist;
        let p = 2*(p1.vx*nx + p1.vy*ny - p2.vx*nx - p2.vy*ny)/(p1.mass + p2.mass);
        p1.vx -= p*p2.mass*nx;
        p1.vy -= p*p2.mass*ny;
        p2.vx += p*p1.mass*nx;
        p2.vy += p*p1.mass*ny;

        let overlap = p1.radius + p2.radius - dist;
        if(overlap > 0){
          p1.x -= nx*overlap/2;
          p1.y -= ny*overlap/2;
          p2.x += nx*overlap/2;
          p2.y += ny*overlap/2;
        }
      }
    }
  }
}

// 三色平滑漸層: 紅 → 淺灰 → 淺藍，speed 對應絕對速度
function getColorByAbsoluteSpeed(speed, referenceSpeed) {
  const t = Math.min(speed / referenceSpeed, 1);
  if (t < 0.5) {
    // 紅 -> 淺灰
    const ratio = t / 0.5;
    const r = Math.floor(255*(1-ratio) + 211*ratio);
    const g = Math.floor(0*(1-ratio) + 211*ratio);
    const b = Math.floor(0*(1-ratio) + 211*ratio);
    return `rgb(${r},${g},${b})`;
  } else {
    // 淺灰 -> 淺藍
    const ratio = (t-0.5)/0.5;
    const r = Math.floor(211*(1-ratio) + 173*ratio);
    const g = Math.floor(211*(1-ratio) + 216*ratio);
    const b = Math.floor(211*(1-ratio) + 230*ratio);
    return `rgb(${r},${g},${b})`;
  }
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let frameImpulse = 0;
  const referenceSpeed = Math.sqrt(initialTemp)/100 * 1.5; // 可調整絕對速度參考

  for (let p of particles) {
    p.x += p.vx;
    p.y += p.vy;

    // 邊界反彈
    if (p.x - p.radius < 0) { frameImpulse += Math.abs(2*p.vx) * 10000; p.vx *= -1; p.x = p.radius; }
    if (p.x + p.radius > canvas.width) { frameImpulse += Math.abs(2*p.vx) * 10000; p.vx *= -1; p.x = canvas.width - p.radius; }
    if (p.y - p.radius < 0) { frameImpulse += Math.abs(2*p.vy) * 10000; p.vy *= -1; p.y = p.radius; }
    if (p.y + p.radius > canvas.height) { frameImpulse += Math.abs(2*p.vy) * 10000; p.vy *= -1; p.y = canvas.height - p.radius; }

    let speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
    ctx.fillStyle = getColorByAbsoluteSpeed(speed, referenceSpeed);

    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, 2*Math.PI);
    ctx.fill();
  }

  handleCollisions();

  impulseHistory.push(frameImpulse);
  if (impulseHistory.length > framesForAverage) impulseHistory.shift();

  let totalImpulse = impulseHistory.reduce((a,b)=>a+b,0);
  let containerLength = 2*(canvas.width + canvas.height);
  let P = totalImpulse / containerLength / impulseHistory.length;
  pressureEl.textContent = P.toFixed(2);

  avgFramesEl.textContent = `幀數: ${impulseHistory.length}`;

  computeStats();

  if(running) requestAnimationFrame(update);
}

document.getElementById("startBtn").onclick = () => {
  if(!running){
    initialTemp = parseFloat(tempInput.value);
    numParticles = parseInt(numInput.value);
    tempInput.disabled = true;
    numInput.disabled = true;
    initParticles();
    running = true;
    update();
  }
};

document.getElementById("resetBtn").onclick = () => {
  running = false;
  tempInput.disabled
  numInput.disabled = false;
  initParticles();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  avgSpeedEl.textContent = "0";
  rmsSpeedEl.textContent = "0";
  pressureEl.textContent = "0";
  avgFramesEl.textContent = "幀數: 0";
};
initParticles();
</script>
</body>
</html>
